# 발표

[1] defi project - 각 프로젝트의 목적은 무엇인지, 어떤 거래소에서 어떤 토큰으로 거래되고 있는지, 어떤 구현 상의 이슈가 있는지, 이론적인 내용은 무엇인지

- [x]  Analytics의 chainbeat
- [x]  Decentralized lending의 compound
- [x]  Payments의 xDai

[2] 프로그램 실행 예제 - 프로그램이 해당 플랫폼에서 어떻게 실행되는지

- [x]  Ethereum(Solidity) - Hop Protocol
- [x]  Ethereum(Solidity) - Celernetwork

## 스마트금융개론 발표 준비

### Defi Project

- **Analytics의 Chainbeat**
    
    Chainbeat는 블록체인 데이터의 구조적 분석, 네트워크 패턴 연구, 실시간 모니터링, 데이터 시각화를 통해 DApp 개발자와 사용자에게 중요한 인사이트를 제공합니다. 이론적 배경으로는 그래프 이론, 시계열 분석, 스마트 컨트랙트 로그 처리 등이 활용되며, 이는 블록체인 기술의 응용 가능성을 확장하는 데 기여합니다.
    
    - 블록체인 데이터 인사이트 제공 : Chainbeat는 블록체인 스마트 컨트랙트의 사용량과 사용자 행동에 대한 심층적인 분석을 통해, DApp 및 프로토콜 개발자들이 Web 3.0 환경에서 사용자 행동을 이해하고 비즈니스 성장을 도모할 수 있도록 지원한다.
    - 실시간 데이터 기반 의사결정 지원  : 실시간 경고 및 맟춤형 보고서를 통해, 개발자들이 빠르게 의사결정을 내리고, 스마트 컨트랙트의 실제 사용 현황을 파악할 수 있도록 돕는다.
    
    Chianbeat는 데이터 분석 플랫폼으로서 자체 토큰을 발행하거나 거래소에 상장된 토큰을 보유하고 있지 않다. 
    
    **Chainbeat 구현 상의 이슈**
    
    1. 다중 블록체인 지원 : 여러 블록체인 네트워크를 지원하기 위해 각 체인의 데이터 구조와 프로토콜에 대한 이해가 필요하다. 
    2. 실시간 데이터 처리 : 블록체인 트랜잭션은 실시간으로 발생하므로, 이러한 데이터를 지연 없이 처리하고 분석하는 것은 상당히 어려울 것이다.
    3. 데이터 정확성 및 무결성 : 분산된 블록체인 환경에서 데이터의 정확성과 무결성을 유지하는 것은 어려운 문제이다. 
    
    **Chainbeat 이론적인 내용**
    
    - 스마트 컨트랙트 분석 : Chainbeat는 스마트 컨트랙트의 이벤트, 트랜잭션, 토큰 전송 등을 모니터링하여 사용량과 성능을 분석한다. 이를 통해 개발자들은 사용자 행동 패턴을 이해하고, DApp의 효율성을 향상시킬 수 있다.
        - 스마트 컨트랙트 로그 : 스마트 컨트랙트는 실행 중 다양한 이벤트 로그를 기록하는데 Chainbeat는 이를 분석한다.
        - 블록체인 상태 데이터 : 블록체인의 특정 시점에서의 상태(계정 잔액, 컨트랙트 상태 등)을 분석하여 실시간 데이터와 과거 데이터를 비교한다.
    - 데이터 분석
        - 그래프 이론
            - 송신자와 수신자 간의 트랜잭션 흐름을 노드(사용자/컨트랙트)와 엣지(트랜잭션)으로 표현
        - 사용자 행동 분석
            - 사용자의 지갑 주소 활동을 분석하여 빈도, 패턴, DApp과의 상호작용을 파악한다. → Chainbeat는 이를 통해 주요 사용자 그룹을 분류한다.
        - 트랜잭션 활동 모니터링
            - 시간대별 트랜잭션 빈도 분석하여 네트워크 피크 타임과 트래픽 변동 파악
        - 사용량 변화 추적
            - 스마트 컨트랙트 사용량의 증감 추세를 분석하여 DApp의 성장 가능성 평가
        - 이벤트 기반 분석
            - 스마트 컨트랙트 이벤트 로그 분석
                - 특정 컨트랙트가 호출된 이유와 결과 파악
            - 실시간 경고 시스템
                - 특정 이벤트(대규모 자산 이동) 발생 시, 실시간 경고 발생 → 보안 위협이나 네트워크 이상 빠르게 파악하는 데 유용하다.
    - 데이터 시각화
        - 노드-엣지 다이어그램
            - 송신자와 수신자를 연결하는 네트워크 다이어그램으로, 주요 트랜잭션 경로 시각화
        - 토큰 흐름 추적 → 토큰 이동 시각화하여 자산 이동 추적
- **Decentralized Lending의 Compound**
    
    Compound는 이더리움 블록체인 기반의 탈중앙화 금융 프로토콜로, 사용자들이 암호화폐를 예치하여 이자를 얻거나 담보를 제공하고 대출을 받을 수 있는 플랫폼이다. → 자산 활용도 향상 / 탈중앙화 대출 제공
    
    Compound는 COMP 토큰, Compound의 거버넌스 토큰으로, 플랫폼의 주요 결정에 대한 투표 권한을 부여한다. COMP 토큰은 바이낸스, 코인베이스 프로 등 다양한 거래소에서 거래된다.
    
    cDAI 토큰은 Compound 프로토콜에서 DAI를 예치할 때 발행하는 이자 수익형 토큰으로, 시간이 자남에 따라 cDAI의 가치가 증가한다. Compound 내에서만 작동하기에 Compound 생태계 유입을 유발하는 역할을 한다. 
    
    구현 상의 이슈로는
    
    1. 스마트 컨트랙트 보안
    2. 가격 변동성 : 암호화폐의 가격 변동 → 담보 가치의 급격한 변화 → 청산 위험
    3. 규제 불확실성 → 규제 환경이 명확하지 않아 법적 리스크 존재
    
    이론적 내용
    
    1. 대출 및 예치 모델
        - 대출 풀(Lending Pool)
            - 사용자들이 자산을 예치하면, 대출 희망자가 사용할 수 있도록 공유 풀에 넣는다.
            - 자산의 공급, 대출은 스마트 컨트랙트에 의해 관리된다.
        - 이자율 결정
            - Compound는 알고리즘 기반 이자율 모델 채택하여 공급과 수요에 따라 이자율이 동적으로 변한다.
                - 공급 많고 수요가 적으면 이자율 하락
    2. 담보 기반 대출 모델
        - 초과 담보화
            - 차입자는 대출 금액보다 높은 가치를 가진 담보를 예치해야 한다.
            - 담보 비율이 허용 수준 이하로 떨어지면 스마트 컨트랙트가 담보를 자동으로 청산한다.
        - 청산 모델
            - 담보의 시장 가치가 차입 금액을 충족치 못하면, 스마트 컨트랙트가 담보를 경매로 판매하거나 대출 금액을 상환한다.
    3. 거버넌스 모델
        - 탈중앙화된 의사결정 위해 COMP 거버넌스 토큰 도입
            - COMP 토큰 보유자 권한
                - 프로토콜 매개변수(담보 비율, 이자율 곡선) 변경
                    - 담보 비율(Loan-to-Value(LTV)) : ETH의 LTV 비율이 75%라면, $100가치의 ETH를 담보로 $75까지 대출이 가능하다는 의미다.
                - 새로운 자산 추가(지원하는 암호화폐 확대)
    4. 경제적 설계
        - cToken 모델
            - Compound에 암호화폐 예치 시, cToken(cETH, cUSDT0를 받는다.
            - cToken은 사용자가 예치한 자산에 대한 권리를 나타내며, 시간이 지남에 따라 증가하는 이자를 반영한다. → 예치 기간 동안 이자가 누적된다.
        - COMP 보상 프로그램
            - 대출자, 차입자에게 COMP 토큰을 보상하여 플랫폼 사용 장려
    5. Compound의 스마트 컨트랙트 구조
    - 핵심 컨트랙트
        - Comptroller : 프로토콜의 중앙 관리 컨트랙트로 담보 비율 확인, 이자율 계산, COMP 분배 등을 수행
        - cToken Contracts : 암호화폐에 대한 스마트 컨트랙트
    - 이자율 : 활용률에 따라 이자율을 계산한다. (Borrowed / Supplied) → 활용률이 높으면 이자율이 높다.
- **Payments의 xDai**
    
    목적
    
    - 빠르고 저렴한 거래 : xDai는 평균 5초의 블록 생성 시간과 낮은 수수료로 빠른 거래를 지원한다.
    - 스테이블코인 기반 결제: xDai는 DAI와 1:1로 연동되어 가치 변동성이 적은 스테이블 코인으로 안정적인 결제를 가능토록 한다.
    
    거래소 및 토큰
    
    - xDai 토큰 : xDai는 자체 네트워크의 기본 통화로 사용된다.
    - 거래소 상장 : xDai는 주로 탈중앙화 거래소(DEX)에서 거래된다.(Sushiswap)
    
    구현 상의 이슈
    
    - 보안 및 중앙화 위험 : 사이드체인은 메인체인보다 보안 수준이 낮을 수 있고, 검증자 수가 적을 경우 중앙화가 될 가능성이 존재한다.
    - 브릿지 의존성 : xDai는 이더리움과의 상호 운용성을 위해 브릿지를 사용하며, 브릿지의 보안 취약점이 전체 네트워크에 영향을 미칠 수 있다. → 이더리움 Layer 2 solution과 경쟁 관계인데, 이용자들은 보안이 더 좋은 Layer 2로 이동할 가능성이 크다.
    
    이론적 내용
    
    - 사이드체인 : xDai는 이더리움의 사이드체인으로, 메인체인의 혼잡을 줄이고 확장성을 높이기 위해 설계되었다.
        - 이더리움 메인체인의 혼잡과 높은 Gas 비용 문제를 해결하기 위해 설계
        - DApp 및 결제 서비스에 적합하도록 빠른 트랜잭션 처리 속도 제공(평균 5초/블록)
    - 스테이블코인
    - 검증자 모델
        - PoA(Proof-of-Authority) 검증 : PoA 합의 알고리즘 사용
            - 블록 생성자는 신뢰할 수 있는 검증자들로 제한
            - 검증자는 블록체인의 안전성과 효율성 유지
            - 빠른 트랜잭션 but 중앙화된 검증자 그룹으로 보안 수준 낮을 수 있다.
    - xDai Bridge : 메인체인과 사이드체인 간 자산 전송을 지원하는 브릿지
        1. 사용자가 이더리움 네트워크에서 DAI→xDai로 교환
        2. DAI는 메인체인에서 잠기고, xDai 네트워크에서 동일한 양의 xDai 발행
        - 반대로도 전환된다.
    - 네트워크 수수료 모델
        - 낮은 Gas 비용 : 거래당 평균 $0.01 이하의 수수료를 제공하고, xDai로 수수료를 지불한다.
        - Gas 효율성 : PoA 합의 알고리즘과 사이드체인 구조로 인해 네트워크 혼잡과 상관없이 안정적인 수수료를 유지한다.
            - 검증자가 블록을 생성하기에 PoW,PoS처럼 경쟁적인 리소스 소비가 없다.
            - 네트워크가 혼잡해도 블록 생성 시간이 짧기에 트랜잭션 처리 속도가 안정적이다.
            - 제한적인 검증자 수를 넘어설 정도의 트랜잭션 처리 용량이 온다면 사이드체인에서도 혼잡이 발생할 수 있겠지만 가능성은 희박하다.

### Ethereum(Solidity) 이론

Hop Protocol, Celernetwork 공통된 부분 먼저 발표 진행하겠습니다.

Ethereum 플랫폼에서의 핵심 작동 원리

- **스마트 컨트랙트 기반**
    - 두 프로토콜 모두 Solidity로 작성된 스마트 컨트랙트를 통해 동작하며, EVM에서 실행됩니다.
    - 트랜잭션 실행 시 상태가 업데이트되며, 이 과정에서 gas 비용이 발생한다.
- **EVM(Ethereum Virtual Machine) 실행 모델**
    - 스마트 컨트랙트는 EVM에서 바이트코드 형태로 실행되며, gas 비용은 명령어의 복잡성과 네트워크 혼잡도에 따라 달라진다.
    - 트랜잭션이 포함된 블록은 네트워크 전체에 전파되어 검증된다.
- **Gas 모델 →** Gas 최적화를 통해 사용자 비용을 최소화하려는 설계
    - 트랜잭션 수수료는 gas와 이더리움의 현재 가격을 기반으로 계산되며, 두 프로토콜 모두 gas 최적화에 신경을 쓴다.
    - Layer 2 솔루션을 활용하여 gas 비용을 최소화하고 빠른 트랜잭션 처리를 지원한다.
    

Cross-chain 자산 전송과 Layer 2 활용

- **Layer 2 확장성 솔루션**
    - Rollup 기술을 사용해 트랜잭션 처리 속도를 높이고 비용을 줄인다.
    - Layer 1은 보안과 최종 확인 역할을 수행한다.
- **Cross-chain 메시징 및 유동성 풀**
    - 유동성 풀을 통해 자산 전송 속도를 향상
    - 메시징 프로토콜을 활용해 Layer1과 Layer2 간 데이터를 동기화
    

보안 및 신뢰 모델

- **스마트 컨트랙트 기반 탈중앙화**
    - 사용자 신뢰를 최소화한 모델을 채택하여 모든 데이터 및 검증 과정을 온체인에서 처리
    - 경제적 인센티브를 제공해 유동성 공급자를 유인
    

구현 상 공통 과제

- **Gas 비용 문제**
    - Ethereum Layer 1의 높은 수수료 문제를 Layer 2를 통해 완화하려 하지만, 완벽한 해결책은 아니다.
    
    ---
    
    ### Q&A
    
    **Q1. Gas cost는 어느 정도인가?**
    
    - 일반적인 스마트 컨트랙트 실행에는 수천-수십만 가스 단위가 필요하다. 예를 들어서 단순 토큰을 전송한다고 하면 약 21,000~65,000 gas / 복잡한 스마트 컨트랙트 호출은 100,000~500,000 gas 이상이 필요하다.
    - Gas 비용은 gas units에 가스 가격을 곱한 값으로, 가스 가격은 Gwei(1ETH = 10^9 Gwei)단위로 설정된다.
    - Hop Protocol
        - Layer 1 트랜잭션 비용 - 유동성 풀에 자산을 전송하거나 상태 동기화 시 발생(20,000~50,000 가스)
        - Layer 2 전송 비용 - ZK-Rollup 사용 시 약 10배 이상 비용 절감 가능
    
    **Q2. Gas 비용을 매기는 원리는?**
    
    - 각 EVM 명령어는 고정된 Gas 비용이 할당된다.
    - ADD - 3gas / STORE - 최대 20,000 gas
    - 트랜잭션 실행 중 사용하는 명령어의 총합에 따라 gas 비용이 계산된다. 따라서 데이터를 저장하거나 읽는 복잡한 작업은 더 많은 gas를 요구한다.
    
    **Q3. 트랜잭션 수수료를 매기는 원리는?**
    
    - Transaction fee = Gas Units Used X Gas Price(Gwei)
    - 사용자들은 최대 가스 사용량을 설정하고, 네트워크 혼잡 상황에서 높은 Gas Price를 제시해 우선순위를 확보한다.
    
    **Q4. Gas를 최적화하는 방법은?**
    
    - 효율적인 Solidity 코드 작성 - 불필요한 연산 줄이기
    - Assembly 코드 활용 : 특정 작업에서 Gas 비용 절감
    - Layer 2 solution 사용 : 대규모 연산을 Layer 2에서 처리해 Layer 1에서의 Gas 소모를 줄인다.
    
    **Q5. Layer 2 solution이란?**
    
    - Layer 2는 Ethereum Layer 1 위에서 동작하며, 트랜잭션을 처리한 후 결과만 Layer 1로 전송하는 확장성 솔루션이다.
    - Rollup(Optimistic Rollup, ZK-Rollup), Plasma 등이 대표적으로, 트랜잭션 속도를 높이고 비용을 낮춘다.
    
    **Q6. Layer 1의 역할은 무엇인가?**
    
    - Layer 1(Ethereum의 메인넷) - 보안, 데이터 저장, 최종성(Finality) 보장
    - Layer 2에서 처리된 트랜잭션 결과를 검증하고, 데이터 무결성을 유지하는 역할을 한다.
    
    **Q7. Cross-chain이란?**
    
    - Cross-chain은 서로 다른 블록체인 간에 자산이나 데이터를 전송할 수 있는 기술을 의미한다.
        - Hop Protocol, Celer Network는 자산이 특정 체인에 고정되지 않고 자유롭게 이동할 수 있도록 지원한다.
        
    
    **Q8. 유동성 풀을 통해 자산 전송 속도를 어떻게 향상시키나요?**
    
    - 유동성 풀은 자산을 미리 공급해 둠으로써 사용자가 다른 체인으로 자산을 이동할 때 대기 시간을 줄인다.
        - A 체인에서 B 체인으로 자산을 전송하려는 사용자는 실제로 자산을 이동하지 않고, 유동성 풀에서 이미 준비된 자산으로 교환한다.
        
    
    **Q9. 메시징 프로토콜을 어떻게 활용해 Layer 1과 Layer 2 데이터를 동기화하는지?**
    
    - 메시징 프로토콜은 Layer 2에서 처리된 트랜잭션 데이터를 Layer 1으로 제출해 최종 확인을 받는 방식으로 동작한다.
        - Rollup의 경우, Merkle Tree를 이용해 Layer 2에서 처리된 데이터의 해시를 Layer 1에 업로드하고, 필요시 증명을 통해 데이터를 검증한다.
        
    
    **Q10. 남아 있는 Gas 비용 문제는 무엇인가?**
    
    - Layer 2 솔루션을 사용해도 잔존하는 문제가 있다.
        - Rollup 비용 : Layer 2 데이터를 Layer 1에 업로드할 때 발생하는 기본적인 Gas 비용이 여전히 높다.
        - 네트워크 혼잡 : Layer 2 트랜잭션이 증가하면 Layer 1으로 업로드되는 데이터 양이 늘어나 추가적인 Gas 비용이 발생한다.
        - Gas 시장 불안정성 : 네트워크 사용량에 따라 Gas Price가 급격히 변동할 수 있다.
        
    
    **Q11. Rollup이란?**
    
    - Rollup은 Ethereum Layer 2 확장성 솔루션의 한 형태로, 대량의 트랜잭션 데이터를 Layer 2에서 처리한 뒤 이를 압축하여 Layer 1로 제출하는 방식이다.
        - Batching : 여러 트랜잭션을 하나로 묶어 Layer 1에 압축된 형태로 제출한다. 이 과정에서 불필요한 데이터 제거
        - Layer 1은 Rollup이 제출한 데이터의 유효성을 검증하거나, 필요시 사용자가 증명을 제출할 수 있도록 지원
        - Merkle Tree 활용 : Rollup은 트랜잭션 데이터를 Merkle Tree로 정리하여 Layer 1에 Merkle Root(해시)만 저장한다.  → 이를 통해 데이터 무결성 확인 가능
    - 유형
        - Optimistic Rollup
            - Layer 1로 전송된 데이터를 기본적으로 신뢰, 이의가 있을 경우 ‘Fraud Proof(사기 증명)’로 잘못된 트랜잭션을 검증
            - 데이터 검증 비용이 낮지만, Fraud Proof 검증에는 시간이 소요된다.
        - ZK-Rollup(Zero-Knowledge Rollup)
            - ZK Proof를 통해 모든 트랜잭션이 올바르게 처리되었음을 암호학적으로 증명하여 Layer 1에 제출
            - 빠르고 안전하지만 초기 검증 비용이 높다.
            
    
    **Q12. Assembly 코드 활용이 어떤 작업에서 Gas 비용이 절감되는지**
    
    Solidity보다 저수준 명령어를 직접 사용하여 불필요한 연산 줄이거나 특정 EVM 동작 최적화 가능하다.
    
    1. 수학 연산 최적화 - Solidity는 오버플로우/언더플로우 방지 위해 검증 코드 추가 / Assembly는 검증 과정 생략하고 순수 연산만 수행하여 gas 비용 줄인다
    
    ```solidity
    assembly {
    	let result := add(x,y) //Solidity의 SafteMath를 대체
    }
    ```
    
    1. 메모리/스토리지 접근 최적화 - Assembly는 직접 메모리 주소 지정하여 비용 줄인다. 
    2. 반복문 실행 중 중복된 연산 - Assembly로 대체 
    3. 특수 Opcode 사용 - Solidity로는 직접 접근할 수 없는 EVM의 특수 opcode (EXTCODEHASH, CALLCODE 등)

---

### Hop Protocol

1. **Layer 2 간 자산 전송 최적화**
- Hop Protocol은 Ethereum의 Layer 2 솔루션 간의 자산 전송을 빠르고 효율적으로 지원하는데 중점을 둔다.
- Layer 1과 Layer 2 간 브리징도 가능, Layer 2 이동에서 더 큰 강점 보인다.

1. **Bonders 역할**
- Bonders는 사용자의 트랜잭션 요청을 즉시 처리하기 위해 유동성을 제공하며, 후속적으로 Layer 2 트랜잭션을 정산
- Bonders는 수수료를 통해 경제적 인센티브를 받는다.

1. **AMM(Automated Market Maker) 기반 유동성 풀**
- 자산 전송은 AMM 모델을 사용하여 유동성 풀이 서로 다른 체인에서 자산을 교환하도록 설계
- Ethereum에서 Polygon으로 전송할 때, AMM 풀에서 자산을 교환하여 빠른 전송을 지원한다.

1. Layer 2 전송 최적화
    - ZK-Rollup, Optimistic Rollup과 같은 Layer 2 솔루션과의 호환성이 뛰어나다.
    - 트랜잭션을 묶어서 처리하는 방식으로 효율성을 극대화
    
2. Cross-chain 메시징 최적화
    - 최소한의 데이터만 Layer 1로 전송하여 Gas 비용 절감
    
3. 멀티체인 DApp 지원
    - 사용자가 여러 Layer 2 네트워크에서 동일한 DApp을 원할히 사용할 수 있도록 지원

### Q&A

**Q1. Layer 2 이동에서 Hop Protocol은 어떻게 더 강점을 보이는지**

- Hop Protocol은 Layer 2 간의 직접적인 자산 이동에 특화돼 있다. 일반적으로는 Layer 2→Layer1→Layer2로 이동하려면 여러 단계의 트랜잭션과 높은 gas 비용이 소요된다.
- Hop Protocol은 자체적인 Cross-Rollup 유동성 네트워크를 사용해 Layer 1을 거치지 않고 바로 Layer 2 간 이동을 처리하기에 시간과 비용을 절약한다.

**Q2**. **Bonders에 대한 자세한 설명**

- Bonders는 Hop Protocol에서 유동성을 제공하고, 사용자의 자산 이동을 즉시 처리하는 역할은 하는 참여자들이다.
    - 사용자가 Layer 2-A에서 Layer 2-B로 자산을 전송하려고 할 때, Bonder는 Layer 2-B에서 자산을 미리 사용자에게 제공하고 나중에 정산한다.
- 이를 통해 사용자는 Layer 1에서 Rollup 트랜잭션을 기다릴 필요 없이 빠른 전송이 가능하다. 유동성 제공자는 나중에 Layer 1 정산 과정에서 보상받는다.(최종성)

---

### Celer Network

1. **Omnichain Interoperability** 
    - Celer Network는 단순 자산 전송을 넘어, 스마트 컨트랙트의 Cross-chain 실행을 지원하는 Omnichain Interoperability Framework 제공
    - Layer 1과 Layer 2뿐 아니라 다양한 블록체인 간 상호작용에 초점을 맞춤.
    
2. **State Guardian Network(SGN)**
    - Celer의 핵심 네트워크로, Cross-chain 메시징과 상태 관리(State Management)를 담당
    - 사용자가 연결된 모든 체인의 상태를 안전하게 유지, 동기화
    
3. **Celer IM(Message Protocol)**
    - Cross-chain 메시지 전송을 위한 전용 프로토콜 - 스마트 컨트랙트 호출 및 데이터 동기화 지원
    - 한 블록체인에서 발생한 이벤트를 다른 체인의 스마트 컨트랙트에 전달
    
4. **cBridge**
    - 자산 전송을 위한 전용 Cross-chain 브리징 솔루션
    - 낮은 수수료와 빠른 전송 강조, 다양한 네트워크 지원
    
5. **Omnichain DApp 개발 지원**
    - Celer SDK를 통해 개발자들이 Cross-chain 스마트 컨트랙트를 손쉽게 작성할 수 있도록 지원
    - NFT 마켓플레이스가 여러 체인에서 동시에 작동하도록 구현 가능
    
6. 사례 
    - Cross-chain Defi와 NFT 지원
        - Celer는 자산 전송뿐만 아니라 NFT 브리징, Cross-chain 대출 등 Defi 생태계 전반에 걸친 솔루션 제공

### Q&A

**Q1. Hop Protocol은 Cross-chain을 실행을 지원하지 않나?**

- Hop Protocol은 주로 Cross-chain 자산 전송을 지원하며, 스마트 컨트랙트 실행에는 초점이 맞춰져 있지 않다.
- Celer Network는 Cross-chain 스마트 컨트랙트 실행을 중심으로 설계됐다.
- Hop은 자산 이동을 효율적으로 처리하는 데 좋으며, Celer는 스마트 컨트랙트 호출과 데이터 동기화까지 포함한 더 복잡한 상호작용을 지원한다.

**Q2. Hop Protocol의 멀티체인 DApp 지원과 Celer Network의 다양한 블록체인 간 상호작용 차이점은?**

- Hop Protocol
    - Layer 2 network 간 DApp이 동일한 사용자 자산을 공유하도록 지원
    - 사용자가 Optimism과 Arbitrum에서 동일한 DApp을 사용할 때 자산을 빠르게 이동
- Celer Network
    - Cross-chain 상호작용을 통해 DApp이 여러 블록체인에서 동시에 작동하도록 지원
    - 사용자가 Ethereum, BNB chain, Avalanche에서 동일한 스마트 컨트랙트 호출 가능
    

**Q3. SGN(State Guardian Network)란?**

SGN은 Celer Network의 핵심 모듈 - Cross-chain 메시징과 상태 동기화 기능을 제공한다.

- Cross-chain 메시지 보관 : 각 체인에서 발생한 메시지를 저장하고 동기화
- 상태 유지 및 검증 : 여러 블록체인의 상태 추적, 사용자가 필요할 때 증명 데이터 제공
- 보안 : 탈중앙화된 노드 네트워크를 통해 메시지 안전하게 전송, 데이터 무결성 보장

**Q4. Celer IM으로 Cross-chain이 Hop Protocol보다 잘 동작하게 되는 이유?**

- Celer IM(Message Protocol)은 스마트 컨트랙트 호출과 데이터 동기화를 포함한 Omnichain 메시징을 지원한다.

**Q5. Celer SDK란?**

Celer SDK는 개발자가 Cross-chain 스마트 컨트랙트를 쉽게 작성하고 통합할 수 있도록 돕는 개발 도구이다. 

- Cross-chain 트랜잭션 호출 지원
- 다양한 블록체인 네트워크 간 상호작용 추상화
- 코드 몇 줄로 Omnichain DApp 구현 가능

**Q6. NFT 마켓플레이스가 여러 체인에서 동시에 작동하도록 구현할 수 있게 해주는 부분이 무엇인가?**

- Celer IM과 SGN을 통해 NFT 상태를 동기화하고, Cross-chain 거래를 지원합니다.
- 사용자가 Ethereum에서 NFT를 구매하면, Celer IM은 이 정보를 Avalanche나 Polygon의 NFT 컨트랙트로 전달.
- SGN은 체인 간 상태 업데이트를 추적하고, 다른 체인에서도 동일한 NFT 상태를 유지하게 함.
- 결과적으로 사용자는 하나의 인터페이스에서 여러 체인의 NFT를 동시에 관리하거나 거래 가능

---

### 결론

- Hop Protocol은 Layer 2 자산 전송에 최적화된 솔루션으로, 빠르고 저렴한 자산 이동에 초점을 맞춘다.
- Celer Network는 Omnichain Interoperability를 중심으로 더 넓은 범위의 Cross-chain 스마트 컨트랙트 실행과 다양한 블록체인 간 상호작용을 지원

### Ethereum(Solidity) 프로그램이 해당 플랫폼에서 어떻게 실현되는지

- **Hop Protocol 과정**
    1. 사용자 트랜잭션 제출
        - 사용자는 Hop Protocol의 프론트엔드에서 자산 전송 요청을 제출한다.
            - Ethereum Layer 2-A에서 Layer 2-B로 100 USDC 전송
    2. 트랜잭션 처리(EVM에서의 실행) 
        - 사용자의 요청은 Solidity 스마트 컨트랙트로 전달되어 EVM에서 실행된다.
            - Solidity 코드는 트랜잭션의 유효성을 검증하고 상태를 업데이트
            - Gas 비용이 발생하며, 이는 요청의 복잡성에 따라 달라진다.
        - 주요 Solidity 함수
            - **approve()** : 사용자가 자산을 전송할 수 있도록 Hop 스마트 컨트랙트에 권한을 부여한다.
                - EVM에서 토큰의 approve 메서드가 호출된다.
            - **swapAndSend()** : 유동성 풀에서 자산 교환을 수행한 뒤, 대상 Layer 2 네트워크로 전송
            - AVM 모델이 사용되어 자산을 효율적으로 교환
    3. 유동성 풀 및 Bonders의 역할
        - 사용자가 자산을 전송할 때, AMM 풀을 통해 자산이 교환된다.
            - USDC→hUSDC로 변환 후 Layer 2 간 전송
        - Bonders는 사용자가 기다릴 필요 없이 Layer 2-B에서 자산을 먼저 지급하고, 추후에 Bonders는 hopBridge 컨트랙트에 서명된 증거를 제출해 자산을 상환받는다.
    4. Rollup 및 Layer 1 데이터 동기화
        - Rollup 기반 Layer 2 네트워크는 트랜잭션 데이터를 압축하여 Layer 1로 제출
            - Hop Protocol은 Merkle Tree 구조를 활용해 데이터 무결성을 검증한다.
            - Layer 1의 Bridge 컨트랙트가 이를 확인하고, 필요한 경우 Rollup 데이터를 복구한다.
    5. Layer 2 네트워크 상태 업데이트
        - Layer 2 간 전송이 완료되면, Layer 2-B에서 사용자의 자산 상태가 업데이트된다.
            - 사용자는 Layer 2-B 네트워크 지갑에서 자산 확인 가능
            - 이벤트(event TransferCompleted)를 통해 완료 알림 발생
- **Hop Protocol - Solidity로 작성된 주요 컨트랙트**
    1. **HopBridge.sol**
        - Layer 1과 Layer 2 간 데이터 동기화 및 유효성 검증 수행
            - **`sendMessage()`**: 트랜잭션 데이터 전송.
            - **`verifyProof()`**: Merkle Proof로 Layer 2 데이터 검증.
    2. **HopAMM.sol**
        - AMM 기반 자산 교환 로직 구현.
            - **`addLiquidity()`**: 유동성 공급.
            - **`swap()`**: 자산 교환 수행.
    3. **BonderManager.sol**
        - Bonders의 역할과 보상을 관리.
            - **`bond()`**: 자산 전송 요청 처리.
            - **`redeem()`**: Layer 1 정산 후 Bonder가 상환 요청.
- **Celer Network 과정**
    
    Cross-chain 자산 전송(cBridge)
    
    1. 사용자의 요청 제출
        - 사용자가 Ethereum에서 다른 체인으로 자산 전송을 요청
            - Ethereum에서 Avalanche로 100 USDT 전송
    2. Solidity 컨트랙트 호출
        - 사용자의 요청은 Ethereum에서 배포된 cBridge 스마트 컨트랙트로 전달된다.
        - 스마트 컨트랙트는 다음 작업 수행
            - 자산 잠금(lock): 사용자가 전송할 자산 잠금 처리
            - 메시지 생성 : Cross-chain 전송 요청 메시지를 생성하여 SGN에 전달
    3. SGN을 통한 전송 요청 중계
        - SGN은 전송 요청 메시지를 받아 대상 체인으로 전달
            - SGN은 메시지의 유효성을 검증하고 데이터를 암호화해 전송한다.
    4. 대상 체인에서 자산 지급
        - 대상 체인에서 배포된 cBridge 컨트랙트가 메시지를 받아 사용자의 자산을 지급한다.
            - Avalanche의 cBridge 컨트랙트에서 100 USDT 지급
    
    Cross-chain 메시징(Celer IM)
    
    1. 메시지 생성
        - Ethereum에서 특정 이벤트(NFT 거래, 토큰 전송)가 발생하면 Celer IM 컨트랙트가 이벤트를 처리한다.
        - 메시지를 생성하고 SGN에 전달한다
    2. SGN을 통한 메시지 전달
        - SGN은 Ethereum의 Celer IM 컨트랙트로부터 받은 메시지를 다른 체인의 스마트 컨트랙트로 전달
        - 메시지는 암호화된 상태로 전송 - 무결성 보장
    3. 대상 체인에서 스마트 컨트랙트 호출
        - 대상 체인에 배포된 Celer IM 컨트랙트가 메시지를 받아 스마트 컨트랙트를 호출한다.
            - Ethereum에서 발생한 NFT 구매 이벤트가 BNB Chain의 NFT 거래 컨트랙트로 전달
    
    Omnichain DApp 지원
    
    1단계: Solidity 기반 스마트 컨트랙트 배포
    
    - Celer SDK를 활용하여 개발자가 Ethereum 및 기타 블록체인에 스마트 컨트랙트를 배포합니다.
    - Solidity로 작성된 컨트랙트는 각 체인의 상태를 SGN과 동기화합니다.
    
    2단계: 상태 동기화 및 호출
    
    - Celer IM과 SGN을 통해 여러 체인에 배포된 컨트랙트가 동기화됩니다.
        - 예: 사용자가 Ethereum에서 DApp을 통해 거래를 요청하면, Polygon과 Avalanche에서 동일한 상태가 업데이트됩니다.
- **Celer Network - Solidity로 작성된 주요 컨트랙트**
    1. CelerBridge.sol
        - Cross-chain 자산 전송을 처리하는 컨트랙트.
            - **`lockTokens()`**: 자산 잠금 및 메시지 생성.
            - **`releaseTokens()`**: 대상 체인에서 자산 지급.
    2. CelerIM.sol
        - Cross-chain 메시징과 스마트 컨트랙트 호출을 처리.
            - **`sendMessage()`**: 메시지 생성 및 SGN 전달.
            - **`receiveMessage()`**: SGN에서 받은 메시지를 처리.
    3. SGN.sol
        - SGN의 역할을 관리하는 컨트랙트.
            - **`verifyMessage()`**: 메시지의 유효성을 검증.
            - **`relayMessage()`**: 대상 체인으로 메시지 전송.